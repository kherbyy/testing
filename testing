
-- LocalScript: Triggerbot + Advanced ESP + Debugging Tools + Group Teleport
-- Replicates original script's .g command with enhanced debugging and RemoteEvent probe.

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TextChatService = (pcall(function() return game:GetService("TextChatService") end) and game:GetService("TextChatService") or nil)
local StarterGui = game:GetService("StarterGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

--// === Triggerbot (Q toggle) ===
local TriggerBot = {Enabled = false, Blacklist = {"Knife"}}
local BlacklistCache = {}
for _, n in ipairs(TriggerBot.Blacklist) do BlacklistCache[n:lower()] = true end
local function isBlacklisted(tool) return tool and BlacklistCache[tool.Name:lower()] end

local function getMouseTarget()
    local target = Mouse.Target
    if not target then return nil end
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and target:IsDescendantOf(p.Character) then return p end
    end
end

local function getEquippedTool()
    local c = LocalPlayer.Character
    if not c then return nil end
    for _, v in ipairs(c:GetChildren()) do if v:IsA("Tool") and not isBlacklisted(v) then return v end end
end

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.Q then
        TriggerBot.Enabled = not TriggerBot.Enabled
        StarterGui:SetCore("ChatMakeSystemMessage", {Text="[TriggerBot] "..(TriggerBot.Enabled and "ON" or "OFF")})
    end
end)

RunService.RenderStepped:Connect(function()
    if not TriggerBot.Enabled then return end
    local tgt = getMouseTarget()
    if tgt then
        local tool = getEquippedTool()
        if tool then pcall(function() tool:Activate() end) end
    end
end)

--// === Drawing ESP Setup
local DrawingAvailable = false
pcall(function() if Drawing and Drawing.new then DrawingAvailable = true end end)
if not DrawingAvailable then
    StarterGui:SetCore("ChatMakeSystemMessage", {Text="[ESP] Drawing library not available â€” ESP disabled."})
    return
end

--// ESP caches
local esp = {}
local perTarget = {}
local debugMode = false
local ESP_COLOR = Color3.fromRGB(0, 255, 255) -- Cyan

--// Create ESP per player
local function makeESPFor(p)
    if esp[p] then return end

    local nameText = Drawing.new("Text")
    nameText.Size = 9
    nameText.Color = ESP_COLOR
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    local weaponText = Drawing.new("Text")
    weaponText.Size = 9
    weaponText.Color = ESP_COLOR
    weaponText.Center = true
    weaponText.Outline = true
    weaponText.Visible = false

    local function makeBar(color)
        local bar = Drawing.new("Square")
        bar.Filled = true
        bar.Color = color
        bar.Visible = false
        return bar
    end

    -- Box ESP
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = Color3.fromRGB(255, 0, 0)
    box.Visible = false
    box.ZIndex = 2

    local boxOutline = Drawing.new("Square")
    boxOutline.Thickness = 3
    boxOutline.Filled = false
    boxOutline.Color = Color3.fromRGB(0, 0, 0)
    boxOutline.Visible = false
    boxOutline.ZIndex = 1

    esp[p] = {
        Text = nameText,
        WeaponText = weaponText,
        HealthBG = makeBar(Color3.fromRGB(60, 60, 60)),
        HealthBar = makeBar(Color3.fromRGB(0, 255, 0)),
        ShieldBG = makeBar(Color3.fromRGB(60, 60, 60)),
        ShieldBar = makeBar(Color3.fromRGB(0, 150, 255)),
        Box = box,
        BoxOutline = boxOutline
    }
end

local function removeESPFor(p)
    if esp[p] then
        for _, v in pairs(esp[p]) do v:Remove() end
        esp[p] = nil
    end
end

for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then makeESPFor(p) end end
Players.PlayerAdded:Connect(function(p) if p ~= LocalPlayer then makeESPFor(p) end end)
Players.PlayerRemoving:Connect(function(p) removeESPFor(p) perTarget[p.Name] = nil end)

--// Update loop
local function worldToViewportVec(pos)
    local a, on = Camera:WorldToViewportPoint(pos)
    return Vector2.new(a.X, a.Y), on, a.Z
end

RunService:BindToRenderStep("WaveESP_Render", Enum.RenderPriority.Camera.Value, function()
    for p, d in pairs(esp) do
        pcall(function()
            local show = perTarget[p.Name]
            if not show then
                for _, v in pairs(d) do v.Visible = false end
            else
                local char = p.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                local equippedTool = char and char:FindFirstChildOfClass("Tool")
                if hrp and hum then
                    local cframe = char:GetModelCFrame()
                    local pos, on, depth = worldToViewportVec(cframe.Position)
                    if on then
                        local scaleFactor = 1 / (depth * math.tan(math.rad(Camera.FieldOfView / 2)) * 2) * 1000
                        local width, height = math.round(4 * scaleFactor), math.round(6 * scaleFactor)
                        local x, y = math.round(pos.X), math.round(pos.Y)

                        -- Box
                        d.Box.Size = Vector2.new(width, height)
                        d.Box.Position = Vector2.new(x - width / 2, y - height / 2)
                        d.Box.Visible = true
                        d.BoxOutline.Size = d.Box.Size
                        d.BoxOutline.Position = d.Box.Position
                        d.BoxOutline.Visible = true

                        -- Name
                        d.Text.Text = (p.DisplayName or p.Name) .. " (@" .. p.Name .. ")"
                        d.Text.Position = Vector2.new(x, y - height / 2 - 12)
                        d.Text.Visible = true

                        -- Weapon
                        if equippedTool then
                            d.WeaponText.Text = "[" .. equippedTool.Name .. "]"
                            d.WeaponText.Position = Vector2.new(x, y + height / 2 + 12)
                            d.WeaponText.Visible = true
                        else
                            d.WeaponText.Visible = false
                        end

                        -- Bars
                        local barY = d.Box.Position.Y
                        local barHeight = height

                        -- Health (LEFT side)
                        local hpPercent = math.clamp(hum.Health / (hum.MaxHealth or 1), 0, 1)
                        local healthX = d.Box.Position.X - 6
                        d.HealthBG.Position = Vector2.new(healthX, barY)
                        d.HealthBG.Size = Vector2.new(4, barHeight)
                        d.HealthBG.Visible = true
                        d.HealthBar.Position = Vector2.new(healthX, barY + barHeight * (1 - hpPercent))
                        d.HealthBar.Size = Vector2.new(4, barHeight * hpPercent)
                        d.HealthBar.Color = (hpPercent > 0.6 and Color3.fromRGB(0, 255, 0)) or (hpPercent > 0.3 and Color3.fromRGB(255, 255, 0)) or Color3.fromRGB(255, 0, 0)
                        d.HealthBar.Visible = hpPercent > 0

                        -- Shield (RIGHT side)
                        local shieldPercent = 0
                        local shieldObj = p:FindFirstChild("DataFolder") and p.DataFolder:FindFirstChild("Information") and p.DataFolder.Information:FindFirstChild("ShieldSave")
                        local forcefield = p.Character:FindFirstChildOfClass("ForceField")

                        if shieldObj then
                            local val = shieldObj.Value or 0
                            local maxValObj = shieldObj:FindFirstChild("MaxValue")
                            local maxVal = (maxValObj and maxValObj.Value) or 100
                            shieldPercent = math.clamp(val / maxVal, 0, 1)
                        elseif forcefield then
                            shieldPercent = 1
                        end

                        local shieldX = d.Box.Position.X + d.Box.Size.X + 2
                        d.ShieldBG.Position = Vector2.new(shieldX, barY)
                        d.ShieldBG.Size = Vector2.new(4, barHeight)
                        d.ShieldBG.Visible = true
                        d.ShieldBar.Position = Vector2.new(shieldX, barY + barHeight * (1 - shieldPercent))
                        d.ShieldBar.Size = Vector2.new(4, barHeight * shieldPercent)
                        d.ShieldBar.Visible = shieldPercent > 0
                    else
                        for _, v in pairs(d) do v.Visible = false end
                    end
                else
                    for _, v in pairs(d) do v.Visible = false end
                end
            end
        end)
    end
end)

--// === Commands ===
local function clearESP()
    for name, _ in pairs(perTarget) do perTarget[name] = nil end
    StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[ESP] Cleared all targets."})
end

local function toggleESPFor(search)
    search = (search or ""):lower()

    if search == "debug" then
        debugMode = not debugMode
        StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[ESP Debug] " .. (debugMode and "ON" or "OFF")})
        return
    end

    local found = false
    if debugMode then print("Attempting to find player matching '" .. search .. "'") end
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            local n = (p.Name or ""):lower()
            local dname = (p.DisplayName or ""):lower()
            if debugMode then print(" - Checking player: " .. n) end
            if search ~= "" and (n:find(search, 1, true) or dname:find(search, 1, true)) then
                found = true
                perTarget[p.Name] = not perTarget[p.Name]
                StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[ESP] " .. p.Name .. " -> " .. (perTarget[p.Name] and "ON" or "OFF")})
                if debugMode then print(" - Match found!") end
            end
        end
    end
    if not found then
        StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[ESP] No match for '" .. search .. "'"})
        if debugMode then print(" - No matches found.") end
    end
end

--// VIP Whitelist (only these players can use .g/.s and be teleported)
local vip_whitelist = {
    ["misiuperc568"] = true,
    ["afasterpl11"] = true
    -- Add your username or more VIP usernames here
}

--// Bring Targets for smooth teleportation
local BringTargets = {}

--// Position history to detect server rejection
local PositionHistory = {}

--// Smooth Bring Loop (exact replica from original script)
RunService.RenderStepped:Connect(function()
    for targetName, _ in pairs(BringTargets) do
        local target = Players:FindFirstChild(targetName)
        for vipName, _ in pairs(vip_whitelist) do
            local vip = Players:FindFirstChild(vipName)
            if vip and target and vip.Character and target.Character and vip ~= target then
                local vipRoot = vip.Character:FindFirstChild("HumanoidRootPart")
                local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
                if vipRoot and targetRoot then
                    pcall(function()
                        -- Store previous position for rejection detection
                        local prevPos = PositionHistory[target.Name] or targetRoot.Position
                        local targetPos = vipRoot.Position + Vector3.new(0, 3, 0)
                        local dir = (targetPos - targetRoot.Position)
                        targetRoot.CFrame = targetRoot.CFrame + dir * 0.25

                        -- Check if position changed significantly (server rejection)
                        local currPos = targetRoot.Position
                        local movedDistance = (currPos - prevPos).Magnitude
                        if movedDistance < 0.1 and (currPos - targetPos).Magnitude > 1 then
                            if debugMode then
                                print("[GroupTP Debug] Possible server rejection for " .. target.Name .. ": Position not updating (moved " .. movedDistance .. " studs)")
                            end
                            -- Attempt RemoteEvent fallback
                            for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
                                if obj:IsA("RemoteEvent") then
                                    pcall(function()
                                        obj:FireServer("Teleport", target, CFrame.new(targetPos))
                                        if debugMode then
                                            print("[GroupTP Debug] Attempted RemoteEvent " .. obj.Name .. ":FireServer for " .. target.Name .. " to " .. tostring(targetPos))
                                        end
                                    end)
                                end
                            end
                        end

                        PositionHistory[target.Name] = currPos
                        if debugMode then
                            print("[GroupTP Debug] Smooth CFrame update for " .. target.Name .. " to " .. vip.Name .. " at " .. tostring(targetRoot.CFrame))
                        end
                    end)
                else
                    if debugMode then
                        print("[GroupTP Debug] Failed to bring " .. target.Name .. " to " .. vip.Name .. ": Missing HumanoidRootPart")
                    end
                end
            else
                if debugMode then
                    print("[GroupTP Debug] Skipped bringing " .. tostring(targetName) .. " to " .. vipName .. ": Invalid player or character")
                end
            end
        end
    end
end)

local function teleportGroup()
    if not vip_whitelist[LocalPlayer.Name] then
        StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] You are not in the VIP whitelist."})
        if debugMode then print("[GroupTP Debug] Local player " .. LocalPlayer.Name .. " not in vip_whitelist") end
        return
    end

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then
        StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] Failed: No HumanoidRootPart."})
        if debugMode then print("[GroupTP Debug] Failed: Local player has no HumanoidRootPart") end
        return
    end

    local teleported = 0
    for _, p in ipairs(Players:GetPlayers()) do
        if vip_whitelist[p.Name] and p ~= LocalPlayer then
            if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                BringTargets[p.Name] = true
                PositionHistory[p.Name] = p.Character.HumanoidRootPart.Position
                teleported = teleported + 1
                if debugMode then print("[GroupTP Debug] Added " .. p.Name .. " to BringTargets") end
            else
                if debugMode then print("[GroupTP Debug] No HumanoidRootPart for " .. p.Name) end
            end
        else
            if debugMode then print("[GroupTP Debug] Skipped " .. p.Name .. ": Not in vip_whitelist or is local player") end
        end
    end
    StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] Teleporting " .. teleported .. " VIP player(s) to you."})
    if debugMode then print("[GroupTP Debug] Command .g executed by " .. LocalPlayer.Name .. ", teleporting " .. teleported .. " players") end
end

local function stopTeleportGroup()
    if not vip_whitelist[LocalPlayer.Name] then
        StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] You are not in the VIP whitelist."})
        if debugMode then print("[GroupTP Debug] Local player " .. LocalPlayer.Name .. " not in vip_whitelist for .s") end
        return
    end

    local stopped = 0
    for name, _ in pairs(BringTargets) do
        BringTargets[name] = nil
        PositionHistory[name] = nil
        stopped = stopped + 1
        if debugMode then print("[GroupTP Debug] Removed " .. name .. " from BringTargets") end
    end
    StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] Stopped teleporting " .. stopped .. " player(s)."})
    if debugMode then print("[GroupTP Debug] Command .s executed by " .. LocalPlayer.Name .. ", stopped " .. stopped .. " players") end
end

--// Handle incoming .g/.s commands from other VIP players
local function handleIncomingCommand(senderName, msg)
    if not senderName or not msg then
        if debugMode then print("[GroupTP Debug] Invalid senderName or msg: " .. tostring(senderName) .. ", " .. tostring(msg)) end
        return
    end
    local parts = string.split(msg, " ")
    local cmd = (parts[1] or ""):lower()
    if (cmd == ".g" or cmd == "/g" or cmd == "g") then
        if vip_whitelist[senderName] and vip_whitelist[LocalPlayer.Name] then
            local senderPlayer = Players:FindFirstChild(senderName)
            if senderPlayer and senderPlayer.Character and LocalPlayer.Character then
                local senderHRP = senderPlayer.Character:FindFirstChild("HumanoidRootPart")
                local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if senderHRP and myHRP then
                    pcall(function()
                        BringTargets[LocalPlayer.Name] = true
                        PositionHistory[LocalPlayer.Name] = myHRP.Position
                        if debugMode then print("[GroupTP Debug] Added " .. LocalPlayer.Name .. " to BringTargets for " .. senderName) end
                        StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] Teleporting to " .. senderName})
                    end)
                else
                    if debugMode then print("[GroupTP Debug] Failed to teleport to " .. senderName .. ": Missing HumanoidRootPart") end
                end
            else
                if debugMode then print("[GroupTP Debug] Failed to teleport to " .. senderName .. ": Invalid sender or local character") end
            end
        else
            if debugMode then print("[GroupTP Debug] Ignored .g from " .. senderName .. ": Not in VIP whitelist or local player not VIP") end
        end
    elseif (cmd == ".s" or cmd == "/s" or cmd == "s") then
        if vip_whitelist[senderName] and vip_whitelist[LocalPlayer.Name] then
            if BringTargets[LocalPlayer.Name] then
                BringTargets[LocalPlayer.Name] = nil
                PositionHistory[LocalPlayer.Name] = nil
                if debugMode then print("[GroupTP Debug] Removed " .. LocalPlayer.Name .. " from BringTargets for " .. senderName) end
                StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[GroupTP] Stopped teleporting to " .. senderName})
            else
                if debugMode then print("[GroupTP Debug] Ignored .s from " .. senderName .. ": Not in BringTargets") end
            end
        else
            if debugMode then print("[GroupTP Debug] Ignored .s from " .. senderName .. ": Not in VIP whitelist or local player not VIP") end
        end
    end
end

for _, pl in ipairs(Players:GetPlayers()) do
    if pl ~= LocalPlayer then
        pcall(function()
            pl.Chatted:Connect(function(txt) handleIncomingCommand(pl.Name, txt) end)
        end)
    end
end
Players.PlayerAdded:Connect(function(pl)
    if pl ~= LocalPlayer then
        pcall(function()
            pl.Chatted:Connect(function(txt) handleIncomingCommand(pl.Name, txt) end)
        end)
    end
end)

local function processCommand(msg)
    if not msg then
        if debugMode then print("[GroupTP Debug] Invalid command message: " .. tostring(msg)) end
        return
    end
    local parts = string.split(msg, " ")
    local cmd = (parts[1] or ""):lower()

    if cmd == ".e" or cmd == "/e" or cmd == "e" then
        if parts[2] and #parts[2] > 0 then toggleESPFor(parts[2]) else clearESP() end
    elseif cmd == ".g" or cmd == "/g" or cmd == "g" then
        if debugMode then print("[GroupTP Debug] Processing .g command from " .. LocalPlayer.Name) end
        teleportGroup()
    elseif cmd == ".s" or cmd == "/s" or cmd == "s" then
        if debugMode then print("[GroupTP Debug] Processing .s command from " .. LocalPlayer.Name) end
        stopTeleportGroup()
    end
end

if TextChatService then
    local commandsFolder = TextChatService:FindFirstChild("TextChatCommands")
    if not commandsFolder then
        commandsFolder = Instance.new("Folder")
        commandsFolder.Name = "TextChatCommands"
        commandsFolder.Parent = TextChatService
        if debugMode then print("[GroupTP Debug] Created TextChatCommands folder") end
    end
    local cmdName = "WaveESPCommand"
    local cmd = commandsFolder:FindFirstChild(cmdName)
    if not cmd then
        cmd = Instance.new("TextChatCommand")
        cmd.Name = cmdName
        cmd.PrimaryAlias = ".e"
        cmd.SecondaryAlias = "/e"
        cmd.Enabled = true
        cmd.Parent = commandsFolder
        if debugMode then print("[GroupTP Debug] Created WaveESPCommand") end
    end
    cmd.Triggered:Connect(function(a, b)
        local message
        local uid
        pcall(function() if a and a.Message then message = a.Message end end)
        pcall(function() if a and a.Text then message = a.Text end end)
        pcall(function() if b and type(b) == "string" then message = b end end)
        pcall(function() if a and a.UserId then uid = a.UserId end end)
        pcall(function() if a and a.TextSource and a.TextSource.UserId then uid = a.TextSource.UserId end end)
        if not message and a then message = tostring(a) end

        local senderName = nil
        if uid then
            local pl = Players:GetPlayerByUserId(uid)
            if pl then senderName = pl.Name end
        end

        if debugMode then print("[GroupTP Debug] TextChatCommand .e triggered by " .. tostring(senderName) .. ": " .. tostring(message)) end
        if senderName and senderName ~= LocalPlayer.Name then
            pcall(function() handleIncomingCommand(senderName, message) end)
        end

        if uid and uid == LocalPlayer.UserId then processCommand(message) end
    end)

    local gCmdName = "GroupTPCommand"
    local gCmd = commandsFolder:FindFirstChild(gCmdName)
    if not gCmd then
        gCmd = Instance.new("TextChatCommand")
        gCmd.Name = gCmdName
        gCmd.PrimaryAlias = ".g"
        gCmd.SecondaryAlias = "/g"
        gCmd.Enabled = true
        gCmd.Parent = commandsFolder
        if debugMode then print("[GroupTP Debug] Created GroupTPCommand") end
    end
    gCmd.Triggered:Connect(function(a, b)
        local message
        local uid
        pcall(function() if a and a.Message then message = a.Message end end)
        pcall(function() if a and a.Text then message = a.Text end end)
        pcall(function() if b and type(b) == "string" then message = b end end)
        pcall(function() if a and a.UserId then uid = a.UserId end end)
        pcall(function() if a and a.TextSource and a.TextSource.UserId then uid = a.TextSource.UserId end end)
        if not message and a then message = tostring(a) end

        local senderName = nil
        if uid then
            local pl = Players:GetPlayerByUserId(uid)
            if pl then senderName = pl.Name end
        end

        if debugMode then print("[GroupTP Debug] TextChatCommand .g triggered by " .. tostring(senderName) .. ": " .. tostring(message)) end
        if senderName and senderName ~= LocalPlayer.Name then
            pcall(function() handleIncomingCommand(senderName, message) end)
        end

        if uid and uid == LocalPlayer.UserId then processCommand(message) end
    end)

    local sCmdName = "GroupStopCommand"
    local sCmd = commandsFolder:FindFirstChild(sCmdName)
    if not sCmd then
        sCmd = Instance.new("TextChatCommand")
        sCmd.Name = sCmdName
        sCmd.PrimaryAlias = ".s"
        sCmd.SecondaryAlias = "/s"
        sCmd.Enabled = true
        sCmd.Parent = commandsFolder
        if debugMode then print("[GroupTP Debug] Created GroupStopCommand") end
    end
    sCmd.Triggered:Connect(function(a, b)
        local message
        local uid
        pcall(function() if a and a.Message then message = a.Message end end)
        pcall(function() if a and a.Text then message = a.Text end end)
        pcall(function() if b and type(b) == "string" then message = b end end)
        pcall(function() if a and a.UserId then uid = a.UserId end end)
        pcall(function() if a and a.TextSource and a.TextSource.UserId then uid = a.TextSource.UserId end end)
        if not message and a then message = tostring(a) end

        local senderName = nil
        if uid then
            local pl = Players:GetPlayerByUserId(uid)
            if pl then senderName = pl.Name end
        end

        if debugMode then print("[GroupTP Debug] TextChatCommand .s triggered by " .. tostring(senderName) .. ": " .. tostring(message)) end
        if senderName and senderName ~= LocalPlayer.Name then
            pcall(function() handleIncomingCommand(senderName, message) end)
        end

        if uid and uid == LocalPlayer.UserId then processCommand(message) end
    end)
end

pcall(function() LocalPlayer.Chatted:Connect(function(msg) processCommand(msg) end) end)

StarterGui:SetCore("ChatMakeSystemMessage", {Text = "[WaveAI] .e <partial> to toggle ESP | .e debug to toggle debug mode. .g teleports VIP whitelist to you, .s stops teleport (VIP only). Q toggles Triggerbot."})
